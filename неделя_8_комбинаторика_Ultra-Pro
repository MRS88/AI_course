def P(n): #(факторил)
  f =1
  for x in range(2,n+1):
    f*=x
  return f

# Сочетание 
def C_n_m(n,m):
  return P(n)/ (P(n-m)* P(m))

# Размещение 
def A_(n,m):
  return C_n_m(n,m) * P(m)

# Перестановка с повторением
def P_rep(n,m):
  add = 1
  for x in m:
    add*=P(x)
  return P(n)/ add

# Сочетание с повторением
def C_n_m_rep(n,m):
  return P(n+m-1)/ (P(n-1)* P(m))

# Размещение с повторением
def A_rep(n,m):
  return n**m


'''Комбинаторика
Задача 1
Юноша занимается спортом по следующей программе: 3 дня в неделю - легкая атлетика. 2 дня - силовые тренировки. 1 день - плавание. 1 день - отдых.
Сколькими способами он может составить себе расписание занятий на неделю?
Сколькими способами он может составить себе расписание занятий на неделю, если нужно 2 дня на плавание, а не 1?'''

# Перестановка.
from math import factorial as f

print(int(f(7) / f(3)*f(2)*f(1)), '- количество способов в случае 1')
print(int(f(7) / f(2)*f(2)*f(2)), '- если убрать 1 день из атлетики')


'''Задача 2
Сколько различных сочетаний можно получить перестановкой букв в следующем словосочетании: НУЖНО ЛЮБИТЬ МАТЕМАТИКУ И КОТИКОВ?'''

from collections import Counter
from math import factorial as f

# Перестановка. Считаем количество символов по-элементно, включая пробел.
# Используем только значения ключей
s = Counter('НУЖНО ЛЮБИТЬ МАТЕМАТИКУ И КОТИКОВ')
value = s.values()

def factor():
  res = 1
  for i in value:
    res *= f(i)
  return res

int(f(len(s)) / factor())


'''Множества
Задача 1
Доказать, что  A\(A\B)=A∩B .'''

A = {2, 5, 11, 8, 24, 15}
B = {5, 15, 9, 7, 24}

X = A.difference(A.difference(B))
Y = A.intersection(B)
X == Y


'''Задача 2
Доказать, что  A=(A∩B)∪(A\B) .'''

A == (A.intersection(B).union(A.difference(B)))
